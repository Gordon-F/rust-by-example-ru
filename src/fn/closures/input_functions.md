# Входные функции

Так как замыкания могут использоваться в аргументах, вы можете ожидать, что то
же самое можно сказать и про функции. И это действительно так! Если вы
объявляете функцию, принимающую замыкание как аргумент, то любая функция,
удовлетворяющая ограничениям типажа этого замыкания, может быть передана как
аргумент.

```rust,editable
// Объявляем функцию, которая принимает обобщённый тип `F`,
// ограниченный типажом `Fn`, и вызывает его.
fn call_me<F: Fn()>(f: F) {
    f();
}

// Объявляем функцию-обёртку, удовлетворяющую ограничению `Fn`
fn function() {
    println!("Я функция!");
}

fn main() {
    // Определяем замыкание, удовлетворяющее ограничению `Fn`
    let closure = || println!("Я замыкание!");

    call_me(closure);
    call_me(function);
}
```

Стоит отметить, что типажи `Fn`, `FnMut` и `FnOnce` указывают, как
замыкание захватывает переменные из своей области видимости.

### Смотрите также:

[`Fn`][fn], [`FnMut`][fn_mut], and [`FnOnce`][fn_once]

[fn]: https://doc.rust-lang.org/std/ops/trait.Fn.html
[fn_mut]: https://doc.rust-lang.org/std/ops/trait.FnMut.html
[fn_once]: https://doc.rust-lang.org/std/ops/trait.FnOnce.html
